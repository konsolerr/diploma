Устройство веб-сервера.
-----------

Начальная схема устройства любого веб-сервиса достаточно примитивна и приведена на \inlref{рисунке}{img:scheme1}: пользователь делает запрос, а сервер возвращает ему ответ.

\image{scheme1}{Cхема базового веб-сервиса.}

В разделе 2.1 была показана необходимость использовать R и Bioconductor в качестве инструментов для анализа генетической экспрессии. В связи с этим есть несколько подходов к реализации сервиса:

1. Написать всю серверную часть на R. 
2. Написать серверную часть на отличном от R языке, и использовать R, только как язык для анализа данных.

Первую опцию тоже можно рассмотреть с двух сторон:
 
1. Написать свой web-framewrok на языке R с функциональностью, достаточной для совершения всех нужных нам операций.
2. Использовать готовый web-framework на R, и попытаться добиться от него нужной функциональности.

Первый из этих пунктов крайне сложен в реализации, ведь объем нужного от фреймворка функционала достаточно велико, а сам по себе язык недостаточно богат на наработки в области web-разработки.

Второй пункт стоит рассмотреть чуть подробнее. На данный момент существует один фреймворк, который покрыл хотя бы часть, требуемого от него функционала -- фреймворк Shiny. Но Shiny оказался невозможным для использования в этих целях, так как он был спроектирован, как инструмент для одностраничных приложений, чаще всего с одной функциональностью, и из-за этого сложно масштабируем. Так же в нем нет поддержки сессий/пользователей (которые нужны для того, чтобы хранить исследования пользователей на сервере).

Поэтому решено было не использовать язык R для серверных целей. Тогда встаёт вопрос, как установить связь между основным веб-сервером и RBlock.

\image{scheme2}{Вопрос взаимодействия основного веб-сервера и RBlock.}


### Использование OpenCPU ###
OpenCPU как было показано в \inlref{разделе}{content:opencpu} обладает ёмким API для работы с объектами и функциями языка R, поэтому OpenCPU представляется наиболее удачным способом связать наш основным веб-сервер и RBlock. 

Основной веб-сервер не будет работать с объектами языка R -- с ними будет общаться сервер OpenCPU. Основной веб-сервер будет только перенаправлять запросы клиента. Сервер OpenCPU будет вызывать методы языка R, описанные в RBlock, и возвращать объекты языка R, созданные в процессе работы. Основной веб-сервер и сервер OpenCPU будут общаться между собой посредством OpenCPU API. На \inlref{рисунке}{img:scheme2} рассмотрена схема решения.

\image{scheme3}{OpenCPU API связывает основной веб-сервер, обрабатывающий запросы клиента, и сервер OpenCPU, работающий с методами и объектами языка R из RBlock.}

### Устройство RBlock ###
В этой части рассмотрим разработанный формат для устройства кода на R, позволяющий поддерживать нужную функциональность. Введём абстракции Dataset и Presentation.

Абстракция Dataset хранит в себе данные и позволяет совершать над ними операции посредством методов. 

Абстракция Presentation -- представление Dataset в том или ином формате. Абтракция Presentation также хранит данные для представления, но не позволяет совершать над ними операции.

Здесь и далее для описания формата возвращаемых объектов языка R мы будем использовать формат JSON \cite{JSON}. Мы будем делать это по двух причинам:

1. OpenCPU API может возвращать объекты языка R в формате JSON.
2. Формат JSON является удобным форматом для описания такого рода объектов.


Опишем структуру Dataset.
Дескриптор Dataset -- структура языка R, эквивалентная следующей структуре в формате JSON, описанной на листинге 2.1.
\begin{code}[language=JSON,firstnumber=1,title=Листинг 2.1 -- Описание дексриптора Dataset в формате JSON.]
{
	"name": "Dataset name",
	"class": "Dataset class name",
	"constructor": "Name of function which returns object-descriptor of Dataset's constructor function",
	"methods": "Name of function which returns object-descriptor of Dataset's methods function"
}
\end{code}
Поле "name" -- название Dataset.
Поле "class" -- строковое имя класса языка R, описывающего датасет.
Поле "constructor" -- единственное необязательное поле в списке, имя функции возвращающей дескриптор конструктора.
Поле "methods" -- имя функции возращающей дескриптор функции, ответственной за методы Dataset.

Теперь рассмотрим устройство класса языка R описывающего датасет (поле 'class' дескриптора). В R очень мало конструкций для поддержания шаблонов объектно-ориентированного программирования, понятие "класс" там достаточно размыто относительно других языков. Мы воспользуемся языковой структурой refClass \cite{REFCLASS} для описания класса Dataset. Интерфейс любого класса Dataset приведен на листинге 2.2. Интерфейсом он является в том понимании, что любой класс Dataset должен иметь соответствующие поля и методы.

\begin{code}[language=R,label=lst:interpret, title={Листинг 2.2 -- Интерфейс для класса Dataset, описанный с помощью языковой структуры refClass.}]
DatasetInterface <- setRefClass(
	"DatasetInterface",
	fields = list(
	log="character",
	name="character",
	… #any other class fields
	),
	methods = list(
		initialize = function(...) {...},
		showKnit = function(...) {...},
		… #any other class methods
	)
)
\end{code}

Поле log -- должно содержать в себе код, соответствующий тому, который должен быть исполнен для получения этого объекта класса Dataset.
Поле name -- имя Dataset, которое должен видеть конечный пользователь сервиса. 
Метод initialize -- инициализатор класса. 
Метод showKnit -- функция возвращающая HTML-представление датасета в данный момент. Это может быть любая функция возвращающая HTML, но, как показала практика, очень удобно использовать библиотеку knitr \cite{knitr}, для генерации HTML в среде R.

Теперь рассмотрим функцию methods и формат объекта, который она должна возвращать. Сигнатура функции приведена на листинге 2.3.

\begin{code}[language=R,label=lst:interpret, title=Листинг 2.3 -- Сигнатура функции methods дескриптора класса Dataset.]
example_methods <- function(dataset) {
	...
}
\end{code}

Функция methods принимает единственный аргумент -- объект класса Dataset. Это обусловлено тем, что для каждого отдельного объекта dataset мы можем выбрать различные параметры-аргументы функций, или даже автоматически конфигурировать некоторые аргументы за пользователя.

Рассмотрим структуру результата функции methods в эквивалентной ей структуре в формате JSON, описанной на листинге 2.4.
\begin{code}[language=JSON,firstnumber=1, title=Листинг 2.4 -- Описание дексриптора methods в формате JSON.]
{
	"method_name1": {
				"exec": external_function_name,
			    "description": method description,
				"modificator": true/false,
				"args" : {
						"arg_name": arg_description
					}
			     },
    "method_name2": {...},
    ...
}
\end{code}
Поле method_name1 -- строковый идентификатор метода (например "differential_expression"). 
Поле external_function_name -- строка содержащее название внешней функции производящей вызов данного метода. Функция является внешней в том понимании, что она не является методом класса. Необходимость запуска внешней функции обусловлена тем, что API OpenCPU не позволяет запуск метода объекта. Формально структура внешней функции требует принимать первым аргументом объект класса Dataset, а затем аргументы из дескриптора метода, также внешняя функция должна возвращать  Dataset или Presentation. В связи с этим можно увидеть два подхода в написании функциональности в RBlock: 

1. Писать методы внутри класса Dataset и писать внешнюю функцию, вызывающую методы класса, пример на листинге 2.5;
2. Не писать функциональность внутри класса Dataset и писать внешние функции содержащие функционал, пример на листинге 2.6.

\begin{code}[language=R,label=lst:interpret,title={Листинг 2.5 -- Пример внешней функции, вызывающей метод класса.}]
external_method_example1 <- function(dataset, arg1, arg2) {
	dataset\$method_example(arg1, arg2)
}
\end{code}


\begin{code}[language=R,label=lst:interpret,title=Листинг 2.6 -- Пример внешней функции с функционалом.]
external_method_example2 <- function(dataset, arg1, arg2) {
	#functionality
}
\end{code}

Оба подходы эквивалентны, так как в дальнейшем для применения операций к объектам класса Dataset мы будем вызывать именно внешние функции.

Поле modificator -- истинно если возвращаемое методом значение -- объект класса Dataset, ложно -- если возвращаемое значение -- объект класса Presentation.
Поле args -- аргументы метода.
Дескриптор arg_description -- дескриптор аргумента метода структура эквивалентная структуре в формате JSON, описанной на листинге 2.7.
\begin{code}[language=JSON,firstnumber=1,title=Листинг 2.7 -- Описание дексриптора аргумента в формате JSON.]
{
	"name": "argument_id",
	"required": true/false,
	"description": "argument description",
	"type": "TYPE",
	"*choices": [ value1, value2 … valueN],
	"*default": value_default
}
\end{code}
Поле name -- строковый идентификатор аргумента. Поле required -- истинно, если аргумент обязателен для заполнения, поле description -- строковое описание аргумента, поле type -- тип аргумента, поле type может быть элементом из списка TYPE, TYPE на данный момент поддерживает "integer", "file", "character", "boolean", "select". Если поле type имеет значение select, то необходимо предоставить поле choices -- лист возможных принимаемых значений. В других случаях поле choices игнорируется. Поле default -- значение аргумента по умолчании. Все другие поля игнорируются. Суть дескриптора аргумента -- это описание  аргумента на стороне клиента. Каждый TYPE будет сопоставлен соответствующему типу элементу input в HTML, подробнее об этом рассмотрено в пункте 2.3.1.

Таким образом функция methods из дескриптора Dataset содержит всю необходимую информацию для применения методов и отображения их на стороне клиента.
Кажущаяся на первый взгляд громоздкой структура необходима для достаточного задания любой функциональности в RBlock без необходимости менять код основного веб-сервера и код frontend-сотавляющей.

Функция constructor возвращает информацию о конструкторе класса Dataset; это тот конструктор, которым может воспользоваться клиент, в отличие от initialize -- контруктора класса языка R.

Constructor имеет структуру эквивалентную структуре в формате JSON, описанной на листинге 2.8.
\begin{code}[language=JSON,firstnumber=1, title=Листинг 2.8 -- структура дескриптора конструктора.]
{
	"exec": external_function_name,
	"args" : {
			"arg_name": arg_descriptor
		}
}
\end{code}
Поля этой структуры эквивалентны полям дескриптора метода, за исключением того, что внешняя функция не принимает дополнительного первого аргумента, а принимает лишь аргументы, описанные дескрипторами аргументов.
Построенная структура для описания Dataset, его методов и конструктора достаточна для использования.

Presentation -- облегчённая версия Dataset, хранит в себе только результат применения метода, и предполагается, что к ней нельзя применить другие методы. Всё что нужно от Presentation -- это интерфейс класса. Интерфейс описан на листинге 2.9.
\begin{code}[language=R,label=lst:interpret, title={Листинг 2.9 -- Интерфейс для класса Presentation, описанный с помощью языковой структуры refClass.}]
PresentationInterface <- setRefClass(
	"PresentationInterface",
	fields = list(
	log="character",
	… #any other class fields
	),
	methods = list(
		initialize = function(...) {...},
		showKnit = function(...) {...},
		… #any other class methods
	)
)
\end{code}


На построенной структуре, можно легко описать механизм взаимодействия:

1. Получить все доступные дескрипторы датасетов;
2. Для каждого дескриптора датасета получить дескриптор конструктора;
3. Построить объект-датасет;
4. Получить дескриптор методов данного объекта-датасета;
5. По необходимости применять методы.

Механизм взаимодействия продемонстрирован на \inlref{рисунке}{img:mech}.


\image{mech}{Механизм взаимодействия c RBlock, здесь сlient -- это основной веб-сервер, а server -- сервер OpenCPU. Стрелками изображены запросы и ответы, совершаемые с помощью OpenCPU API.}

