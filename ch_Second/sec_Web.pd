Web
-----------

Начальная схема устройства любого веб-сервиса достаточно примитивна и приведена на \inlref{рисунке}{img:scheme1}: пользователь делает запрос, а сервер возвращает ему ответ.

\image{scheme1}{Cхема базового веб-сервиса}

В разделе 2.1 была показана необходимость использовать R и Bioconductor в качестве инструментов для анализа генетической экспрессии. В связи с этим есть несколько подходов к реализации сервиса:

1. Написать всю серверную часть на R. 
2. Написать серверную часть на отличном от R языке, и использовать R, только как язык для анализа данных.

Первую опцию тоже можно рассмотреть с двух сторон:
 
 * Написать свой web-framewrok на языке R с функциональностью, достаточной для совершения всех нужных нам операций.
 * Использовать готовый web-framework на R, и попытаться добиться от него нужной функциональности.

Первый из этих пунктов крайне сложен в реализации, ведь количество нужного от фреймворка функционала достаточно велико, а сам по себе язык недостаточно богат на наработки в области web-разработки.

Второй пункт стоит рассмотреть чуть подробнее. На данный момент существует один фреймворк, который покрыл хотя бы часть, требуемого от него функционала: ShinyR \cite{ShinyR}. Но и ShinyR не оправдал наших ожиданий, так как он был спроектирован, как инструмент для одностраничных приложений, чаще всего с одной функциональностью, и от этого сложно масштабируем. Так же в нем нет поддержки сессий/пользователей (которые нужны для того, чтобы хранить исследования пользователей на сервере).

Поэтому решено было не использовать язык R для серверных целей. Тогда встаёт вопрос, как установить связь между основным веб-сервером и RBlock.

\image{scheme2}{Вопрос взаимодействия основного веб-сервера и RBlock}


### Использование OpenCPU ###
OpenCPU как было показано в \inlref{разделе}{content:opencpu} обладает ёмким API для работы с объектами и функциями языка R, поэтому OpenCPU представляется наиболее удачным способом связать наш основным веб-сервер и RBlock. На \inlref{рисунке}{img:scheme2} показано решение.

\image{scheme3}{OpenCPU, как связь с RBlock}

### Устройство RBlock. ###
В этой части рассмотрим разработанный формат для устройства кода на R, позволяющий нам поддерживать нужную функциональность. Введём абстракции Dataset и Presentation.

Dataset -- по сути хранит в себе данные и позволяет совершать над ними операции посредством методов. 

Presentation -- представление Dataset в том или ином формате. Presentation также хранит данные в том или ином формате для представления, но не позволяет совершать над ними операции, его назначение -- представление данных. 

Опишем структуру Dataset.
Дескриптор Dataset -- структура языка R, эквивалентная следующей структуре в формате JSON:
\begin{code}[language=JSON,firstnumber=1]
{
	"name": "Dataset name",
	"class": "Dataset class name",
	"constructor": "Name of function which returns object-descriptor of Dataset's constructor function",
	"methods": "Name of function which returns object-descriptor of Dataset's methods function"
}
\end{code}
"constructor" -- единственное необязательное поле в списке

Теперь рассмотрим устройство класса R описывающего датасет (поле 'class' дескриптора). В R очень мало конструкций для поддержания шаблонов объектно-ориентированного программирования, понятие "класс" там достаточно размыто относительно других языков. Мы воспользуемся языковой структурой refClass \cite{REFCLASS} для описания Dataset. Здесь мы опишем интерфейс любого Dataset (интерфейс в том понимании, что любой класс Dataset должен иметь соответствующие поля и методы)

\begin{code}[language=R,label=lst:interpret]
DatasetInterface <- setRefClass(
	"DatasetInterface",
	fields = list(
	log="character",
	name="character",
	… #any other class fields
	),
	methods = list(
		initialize = function(...) {...},
		showKnit = function(...) {...},
		… #any other class methods
	)
)
\end{code}

В приложении , можно увидеть код для Dataset генетической экспрессии.
Поле log -- должно содержать в себе код, соответствующий тому, который должен быть исполнен для получения этого Dataset.
Поле name -- имя Dataset, которое должен видеть конечный пользователь сервиса. 
Метод initialize -- инициализатор класса. 
Метод showKnit -- функция возвращающая HTML-представление датасета в данный момент. Это может быть любая функция возвращающая HTML, но, как показала практика, очень удобно использовать библиотеку knitr \cite{knitr}, для генерации HTML в среде R.

Теперь рассмотрим функцию methods, и формат объекта, который она должна возвращать:
Сигнатура функции:

\begin{code}[language=R,label=lst:interpret]
example_methods <- function(dataset) {
	...
}
\end{code}

Функция methods принимает единственный аргумент -- объект класса Dataset. Это обусловлено тем, что для каждого отдельного объекта dataset, мы можем выбрать различные параметры-аргументы функций, или даже конфигурировать некоторые аргументы за пользователя.

Рассмотрим структуру результата функции methods в эквивалентной ей структуре в формате JSON:
\begin{code}[language=JSON,firstnumber=1]
{
	"method_name1": {
				"exec": external_function_name,
			           "description": method description,
				"modificator": true/false,
				"args" : {
						"arg_name": arg_description
					}
			     },
    "method_name2": {...},
    ...
}
\end{code}
Поле method_name1 -- строковый id метода (например "differential_expression"). 
external_function_name -- строка содержащее название внешней функции производящей вызов данного метода. Внешней функция, является в том понимании, что она не является методом класса. Необходимость запуска внешней функции обусловлена тем, что API OpenCPU не позволяет запуск метода объекта. Формально структура внешней функции требует принимать первым аргументом объект класса Dataset, а затем аргументы из дескриптора метода, также внешняя функция должна возвращать  Dataset или Presentation. В связи с этим можно увидеть два подхода в написании функциональности в RBlock: писать методы внутри класса Dataset и затем писать внешнюю функцию вида

\begin{code}[language=R,label=lst:interpret]
external_method_example1 <- function(dataset, arg1, arg2) {
	dataset\$method_example(arg1, arg2)
}
\end{code}

Либо не писать функциональность внутри класса Dataset и писать внешние функции вида

\begin{code}[language=R,label=lst:interpret]
external_method_example2 <- function(dataset, arg1, arg2) {
	#functionality
}
\end{code}

Оба подходы эквивалентны, так как в дальнейшем для применения операций к Dataset мы будем вызывать именно внешние функции.
modificator -- true если возвращаемое методом значение -- Dataset, false -- если возвращаемое значение -- Presentation.
args -- аргументы метода.
arg_description -- дескриптор аргумента метода структура эквивалентная структуре в JSON:
\begin{code}[language=JSON,firstnumber=1]
{
	"name": "argument_id",
	"required": true/false,
	"description": "argument description",
	"type": "TYPE",
	"*choices": [ value1, value2 … valueN],
	"*default": value_default
}
\end{code}
name -- строковый идентификатор аргумента. required -- true если аргумент обязателен для заполнения, description -- строковое описание аргумента, type -- тип аргумента, TYPE на данный момент поддерживает "integer", "file", "character", "boolean", "select". если type имеет значение select -- то необходимо предоставить поле choices -- лист возможных принимаемых значений. В других случаях поле choices игнорируется. default -- значение аргумента по умолчании. Другие поля игнорируются. Суть дескриптора аргумента есть описание  аргумента на стороне клиента. Каждый TYPE будет сопоставлен соответствующему типу элементу input в HTML, подробнее об этом пункте 2.3.1 .

Таким образом функция methods из дескриптора Dataset содержит всю необходимую информацию для применения методов и отображения их на клиенте.
Кажущаяся на первый взгляд громоздкой структура необходима для достаточного задания любой функциональности в RBlock без необходимости менять код основного web-server и код frontend.

Функция constructor возвращает информацию о конструкторе класса Dataset; это тот конструктор, которым может воспользоваться клиент. Constructor имеет структуру эквивалентную структуре JSON:
\begin{code}[language=JSON,firstnumber=1]
{
	"exec": external_function_name,
	"args" : {
			"arg_name": arg_descriptor
		}
}
\end{code}
Поля этой структуры эквивалентны полям дескриптора метода, за исключением того, что внешняя функция не принимает дополнительного первого аргумента, а принимает лишь аргументы, описанные дескрипторами аргументами.
Построенная структура для описания Dataset, его методов и конструктора достаточна для использования.

Presentation -- облегчённая версия Dataset, хранит в себе только результат применения метода , и полагается, что к ней нельзя применить другие методы. Всё что нужно от Presentation -- это интерфейс класса.
\begin{code}[language=R,label=lst:interpret]
PresentationInterface <- setRefClass(
	"PresentationInterface",
	fields = list(
	log="character",
	… #any other class fields
	),
	methods = list(
		initialize = function(...) {...},
		showKnit = function(...) {...},
		… #any other class methods
	)
)
\end{code}


На построенной структуре, можно легко описать механизм взаимодействия, он показан на \inlref{рисунке}{img:mech}

1. Получить все доступные дескрипторы датасетов
2. Для каждого дескриптора датасета получить дескриптор конструктора
3. Построить объект-датасет
4. Получить дескриптор методов данного объекта-датасета
5. По необходимости применять методы


\image{mech}{Механизм взаимодействия c RBlock}

